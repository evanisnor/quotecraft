# Decisions — February 28, 2026

## Task: INFR-US6-A008 — Update developer documentation and ensure Makefiles support a complete development experience

**Requirements:** 1.8.5

### Decisions

**`widget-build` added to root Makefile**

A `make widget-build` target was added to the root Makefile, delegating to `$(MAKE) -C widget build`. This follows the existing pattern for database targets (`$(MAKE) -C api db-migrate`). The target allows a developer to build the production widget bundle (content-hashed) without starting the full dev stack.

**`services-up` comment updated to mention MinIO**

The `services-up` comment previously said "(PostgreSQL)". Since A003 added MinIO to Docker Compose, the comment was updated to "(PostgreSQL, MinIO)" to accurately reflect what the target starts. This is documentation accuracy, not a behavior change.

**README updated in place (not replaced)**

An existing `README.md` was found at the repo root. It was updated rather than replaced: MinIO was added to the dev stack description, `make widget-build` was added to the commands table, and three new sections were added (Development URLs, Widget Bundle, Configuration). The new sections cover the full CDN local-dev workflow introduced by INFR-US6 A003–A007.

**Widget bundle URL annotated for context**

The "Development URLs" table entry for the widget bundle includes "(when `make dev` is running)" because the URL is only valid when both the API server and widget watch process are active. This prevents developer confusion if the URL is tried before `make dev`.

**Configuration table mirrors config.yaml directly**

The Configuration section documents `cdn.serve_local`, `cdn.widget_dir`, `cdn.base_url`, and `storage.provider` with their exact default values from `config.yaml`. This avoids documentation drift — the table is easy to verify against the source of truth.

### Technical Challenges

**INFR-US6-A008 was missing from PROJECT_STATUS.md** — the task was listed in PROJECT_PLAN.md but not in the status tracking file. Added it with `✅ 2026-02-28` as part of this commit.

---

## Task: BLDR-US1-A001 — Set up React app with routing and auth state management

**Requirements:** 1.1.3, 1.2.2, 1.2.4

### Decisions

**Testing dependencies installed: @testing-library/react, @testing-library/jest-dom, @testing-library/user-event, jest-environment-jsdom, ts-jest, @types/jest**

All packages added as devDependencies in dashboard/package.json. `ts-jest` is available but not used directly — Next.js's `next/jest.js` integration handles TypeScript transformation automatically via babel. `@types/jest` is required for TypeScript to recognize `describe`, `it`, `expect`, and `jest.*` globals.

**jest.config.ts uses `next/jest.js` with ES module export**

Following the SKILL.md convention, `jest.config.ts` uses `import nextJest from 'next/jest.js'` and `export default createJestConfig(config)`. Jest setup uses `setupFilesAfterEnv` pointing to `jest.setup.ts` which imports `@testing-library/jest-dom`.

**`@types/jest` added to tsconfig.json `types` array**

Without `"types": ["jest"]` in tsconfig.json, TypeScript cannot find `describe`, `it`, `expect`, and `jest.*` in test files. This is a deliberate addition to the tsconfig that is workspace-safe.

**eslint.config.mjs updated to ignore `coverage/**`**

A leftover `coverage/` directory from an unsuccessful `--coverage` test run would cause ESLint to complain about a generated file. Added `coverage/**` to the globalIgnores list to prevent this.

**AuthState and AuthAction as discriminated unions in model/types.ts**

`AuthState` uses status discriminants: `'loading'`, `'unauthenticated'`, `'authenticated'`. The `'authenticated'` state carries a `token` property. `AuthAction` covers `auth_initialized` (with optional token), `login_succeeded` (with token), and `logout`.

**Pure reducer with no side effects in model/authReducer.ts**

The reducer is a pure function — no localStorage access, no side effects. localStorage sync is handled separately in `AuthContext.tsx` via a `useEffect` that watches `state`. This keeps the reducer testable in isolation.

**Two separate contexts for state and dispatch**

`AuthStateContext` and `AuthDispatchContext` are exported separately. This avoids re-rendering components that only consume dispatch when state changes. Follows the pattern from SKILL.md's `useConversations`/`useConversationsDispatch` example.

**localStorage access only in useEffect**

The `AuthProvider` never accesses `localStorage` during render. Two effects handle this:
1. Mount effect — reads localStorage and dispatches `auth_initialized`
2. State-watch effect — writes/clears localStorage when state becomes `authenticated` or `unauthenticated`

This prevents hydration mismatches in SSR (Next.js server never has access to localStorage).

**`useAuthState` and `useAuthDispatch` throw when used outside provider**

Both hooks check for null context and throw with descriptive error messages. This follows the pattern from SKILL.md.

**In-memory LocalStorageStub in tests (not jest.fn() mocks)**

Per SKILL.md convention, the test file contains a `LocalStorageStub` class that implements the `Storage` interface using a `Map<string, string>`. It is assigned to `window.localStorage` in `beforeEach`. This avoids per-test mocks and provides a realistic, reusable test double.

**The initial `loading` state is not directly observable in tests**

In the jsdom test environment, React Testing Library's `renderHook` wraps renders in `act()`, which flushes effects synchronously. The `loading` state transitions to `unauthenticated` or `authenticated` before `result.current` can be read. The `loading` state is validated by `authReducer.test.ts` (which tests the initial state shape) and by the type system. The provider tests focus on what is observably verifiable: post-hydration states and localStorage sync behavior.

**Next.js App Router route groups: `(auth)` and `(dashboard)`**

- `(auth)` group: `/login` and `/register` pages — no special layout
- `(dashboard)` group: layout with auth guard that redirects unauthenticated users to `/login`
- Root page (`/`) redirects based on auth state using `useRouter().replace()`

**Next.js 15+ async params in editor page**

The `[id]` dynamic segment uses `params: Promise<{ id: string }>` with `async/await` per the Next.js 15+ App Router pattern.

**`'use client'` directives placed only where needed**

- `entities/user/model/AuthContext.tsx` — uses hooks and browser APIs
- `app/providers.tsx` — renders a client component
- `app/page.tsx` — uses `useAuthState` and `useRouter` hooks
- `app/(dashboard)/layout.tsx` — uses `useAuthState` and `useRouter` hooks
- All other pages remain server components (no hooks)

### Technical Challenges

**`--coverage` flag breaks with the workspace-wide `minimatch` override**

The root `package.json` has a pnpm override forcing `minimatch@^10.2.3`. The `test-exclude@6.0.0` transitive dependency (used by Jest coverage instrumentation) requires `minimatch@^3.0.4` and calls `minimatch()` as a function directly. In minimatch v10, the function API changed (now requires `new Minimatch()` or uses different exports). This is a pre-existing workspace environment issue that breaks `jest --coverage`. Tests without `--coverage` run correctly. Removing the `collectCoverageFrom` option from jest.config.ts avoids triggering the broken path during normal test runs.

**Code review follow-up: `LocalStorageStub` extracted to `testing.ts`**

Per SKILL.md convention, reusable test implementations should live in a `testing.ts` file co-located with the slice, not inline in a test file. `LocalStorageStub` was moved from `AuthContext.test.tsx` to `entities/user/model/testing.ts` and re-exported. `AuthContext.test.tsx` now imports from `./testing`.

**Code review follow-up: additional `auth_initialized` reducer tests**

Added two tests covering `auth_initialized` dispatched from non-loading starting states (unauthenticated → authenticated with token; authenticated → unauthenticated without token). This closes the branch coverage gap noted in the review. Total test count: 18 tests across 2 suites.

---

## Task: BLDR-US1-A002 — Build login and registration screens

**Requirements:** 1.1.1, 1.1.3

### Decisions

**FSD layers: entities/user/api for API calls, features/sign-in and features/sign-up for form logic**

Auth API functions (`registerUser`, `loginUser`) live in `entities/user/api/auth.ts` — they are data operations on the user entity. Form state logic lives in `features/sign-in/model/useSignIn.ts` and `features/sign-up/model/useSignUp.ts` — they are user-facing capabilities. Page composition lives in `pages/login` and `pages/register`. The `app/(auth)` route files delegate to the pages layer.

**Fetch injected as parameter for testability**

Both `registerUser` and `loginUser` accept an optional `fetcher` parameter defaulting to `globalThis.fetch`. The `useSignIn` and `useSignUp` hooks forward this parameter. Forms accept an optional `fetcher` prop. This avoids any global fetch mocking in tests — stubs are injected directly.

**`StubFetch` reusable test double in `entities/user/api/testing.ts`**

`StubFetch` implements the fetch interface with a pre-configured response queue. It does not depend on the global `Response` constructor (which may not be available in jsdom). Tests import `stubFetchWith()` factory for convenience.

**auto-login after register: dispatches `login_succeeded`**

On successful registration, `useSignUp` dispatches `{ type: 'login_succeeded', token }`, which stores the token and transitions auth state to `authenticated`. This avoids a separate login step after registration.

**Defensive token guard replaces non-null assertion**

`auth.ts` originally used `envelope.data!.token` after the `!response.ok` guard. This was replaced with an explicit check: if `envelope.data?.token` is falsy on a 2xx response, throw `'Unexpected response: missing token'`. The corresponding test case covers this path.

**Redundant `'use client'` removed from app route pages**

`app/(auth)/login/page.tsx` and `app/(auth)/register/page.tsx` had `'use client'` directives that were redundant — their child page components (`LoginPage`, `RegisterPage`) already establish the client boundary. The directives were removed.

**Page redirect tests use localStorage pre-loading**

`LoginPage.test.tsx` and `RegisterPage.test.tsx` test the redirect-on-authenticated behavior by pre-loading `auth_token` in a `LocalStorageStub` before rendering. The `AuthProvider` hydrates to `'authenticated'` on mount, triggering the redirect `useEffect`. This is more reliable than dispatching `login_succeeded` from a child component in test code.

### Technical Challenges

**Inline `TriggerLogin` component in tests caused redirect to not fire**

An initial approach defined `TriggerLogin` inline inside the test function to dispatch `login_succeeded` and trigger the redirect. This failed: `mockReplace` received 0 calls. The likely cause is React's reconciliation treating the inline function as a new component type on each re-render (different reference = unmount/remount), combined with effect timing in the jsdom environment. Replaced with the simpler localStorage pre-loading approach.

---

## Task: BLDR-US1-A003 — Build calculator list view with create, open, and delete actions

**Requirements:** 1.2.2, 1.2.4, 1.2.7

### Decisions

**FSD layer assignments**

- `entities/calculator` — `CalculatorSummary` type, `listCalculators`/`createCalculator`/`deleteCalculator` API functions, `CalculatorCard` presentational component
- `features/create-calculator` — `useCreateCalculator` hook and `CreateCalculatorButton` component
- `features/delete-calculator` — `useDeleteCalculator` hook and `DeleteConfirmDialog` component
- `pages/dashboard` — `DashboardPage` composition
- `app/(dashboard)/dashboard/page.tsx` — route entry point

**`StubFetch` duplicated in `entities/calculator/api/testing.ts`**

FSD prohibits lateral imports between entity slices. `entities/calculator` cannot import from `entities/user`. The `StubFetch` implementation was duplicated verbatim into `entities/calculator/api/testing.ts`. This is the correct approach per FSD rules — each slice owns its test doubles.

**Fetcher parameter threaded through to `DashboardPage`**

`DashboardPage` accepts an optional `fetcher?` prop and passes it to `listCalculators`, `CreateCalculatorButton`, and `useDeleteCalculator`. This makes the component fully testable via stub injection without any global mocking.

**`useDeleteCalculator`: `confirmingId` cleared before the API call**

When `confirmDelete()` is invoked, `confirmingId` is snapshotted into a local constant, then cleared immediately (replaced with `deletingId`). This prevents the dialog from re-showing if the hook re-renders during the async delete operation and avoids double-submit risk.

**Confirmation dialog rendered inline (no modal library)**

`DeleteConfirmDialog` renders as an inline `div[role="dialog"]` placed after the `CalculatorCard` in the same `li`. This satisfies accessibility requirements with `role="dialog"` and `aria-label="Confirm deletion"` without introducing a dependency on a portal or modal library.

**`DashboardPage` manages the calculator list in local state**

`LoadState` is a discriminated union: `'loading'`, `'error'`, or `'loaded'` (with `calculators: CalculatorSummary[]`). On deletion, `onDeleted(id)` filters the calculator out using a functional state updater. This avoids a second network request to re-fetch the list.

**`useEffect` race condition prevention in `DashboardPage`**

The effect that calls `listCalculators` uses an `ignore` flag (closure variable) to discard stale responses if the component unmounts before the promise resolves. This is the standard pattern from SKILL.md.

**Test query disambiguation with `within()`**

The deletion confirmation test uses `within(firstCard)` to scope the initial Delete button click and `within(dialog)` to scope the confirm Delete click. Without this, `getByRole('button', { name: /delete/i })` matches multiple elements (one per card plus one in the dialog) and throws. `within()` is the correct RTL tool for scoped queries.

### Technical Challenges

**`listSuccessResponse` type parameter uses `typeof CALC_1[]`**

The helper function in `DashboardPage.test.tsx` uses `typeof CALC_1` as the array element type. This infers the exact shape `{ id: string; created_at: string; updated_at: string }` from the fixture constant, which is precisely what the stub needs. No explicit interface needed.
