# Decisions — February 23, 2026

## Task: INFR-US5-A002 — Implement list calculators endpoint (scoped to authenticated user)

**Requirements:** 1.2.2

### Decisions

**`Lister` interface separate from `Creator`**

`ListCalculators` is defined on a new `Lister` interface, separate from `Creator`. `Create` only needs `Creator`; `List` only needs `Lister`. ISP: each consumer takes exactly the capability it needs. `PostgresCalculatorRepository` satisfies both. `NewService` now accepts both `creator Creator` and `lister Lister`. In `main.go`, `calcRepo` is passed for both since `PostgresCalculatorRepository` implements both interfaces.

**`CalculatorLister` defined in `server` package (consumer)**

Per the interfaces-at-consumer convention, `CalculatorLister` is defined in `internal/server/calculator.go`. `CalculatorService` is updated to embed both `CalculatorCreator` and `CalculatorLister`. The `calculator.Service` satisfies both without knowing about the server package.

**`make([]*Calculator, 0)` in `ListCalculators` for empty-list serialization**

Initializing the result slice with `make([]*Calculator, 0)` (rather than `var calcs []*Calculator`) ensures that when zero rows are returned, the variable is a non-nil empty slice. This serializes to `[]` in JSON rather than `null`. The `TestListCalculatorsHandler_Empty` test explicitly asserts `env.Data != nil` to enforce this invariant.

**Query uses `WHERE user_id = $1 AND is_deleted = FALSE ORDER BY updated_at DESC`**

The ownership filter (`user_id = $1`) is enforced at the database level, not the application level. The `user_id` value is derived exclusively from `UserIDFromContext(r.Context())` — the authenticated session — never from user-supplied request parameters. The soft-delete filter (`is_deleted = FALSE`) correctly excludes deleted calculators. Ordering by `updated_at DESC` gives the most recently modified calculator first, which is the natural UX ordering for a builder dashboard.

**`calculatorSummary` response type returns `id`, `created_at`, `updated_at`**

The list response omits `config`, `config_version`, `is_deleted`, and `user_id`. The dashboard needs a name/description per calculator (requirement 1.2.7), but those fields live inside the `config` JSONB and are not yet parsed by the API — that is deferred to the GET endpoint (INFR-US5-A003) and config update (INFR-US5-A004) tasks. The current summary is sufficient for the dashboard to render a list of calculators identified by UUID.

**`rows.Close()` deferred inside `ListCalculators`**

`defer rows.Close()` is called immediately after `QueryContext` succeeds. This is idiomatic Go and ensures rows are closed even if a scan error occurs mid-iteration. The `rows.Err()` check after the loop is still necessary — `rows.Close()` does not surface iteration errors.

### Technical Challenges

**`RowError(0, wantErr)` syntax for sqlmock v1**

sqlmock v1 supports injecting errors into specific rows via the `RowError(rowIndex int, err error)` method on `*Rows`. For `TestListCalculators_RowsError`, a valid row is added first (so `rows.Next()` iterates once), then `RowError(0, wantErr)` is called so that `rows.Err()` returns the configured error after the first row. This exercises the `rows.Err()` error path without triggering a scan failure.

---

## Task: INFR-US5-A003 — Implement get single calculator endpoint (ownership-gated)

**Requirements:** 1.2.2 (implied), INFR-US5 acceptance criteria

### Decisions

**Two-phase fetch: query by `id` only, then ownership check in Go**

`GetCalculator` queries `WHERE id = $1 AND is_deleted = FALSE` — deliberately excluding `user_id` from the WHERE clause. After the row is fetched, a Go-level check `c.UserID != userID` produces `ErrForbidden`. This design allows the repository to return distinct `ErrNotFound` vs `ErrForbidden` signals, enabling the handler to respond 404 vs 403. If the query included `WHERE id = $1 AND user_id = $2 AND is_deleted = FALSE`, both "not found" and "wrong user" would collapse to `sql.ErrNoRows → ErrNotFound`, and we could not return a 403.

**Returning 403 for ownership mismatch (not 404)**

The handler maps `ErrForbidden → 403`, not 404. This is a deliberate product decision documented in the function. It provides clear feedback to dashboard clients (a logged-in user tried to access a calculator they don't own). If the product requirement changes to hide the existence of others' calculators entirely, the behavior can be changed by returning 404 in both `ErrNotFound` and `ErrForbidden` cases.

**`json.RawMessage` for config field**

`calculatorResponse.Config` is `json.RawMessage` so the JSONB column value is embedded as a live JSON object in the API response, not base64-encoded. This is critical for the widget: it must parse the config as a structured JSON document, and a base64-encoded string would require an extra decode step in the widget bundle. The handler casts `calc.Config` (a `[]byte` from PostgreSQL JSONB) to `json.RawMessage` directly — zero-copy, no re-parsing.

**`ErrNotFound` and `ErrForbidden` sentinel errors in `calculator` package**

Following the pattern from `auth` (where `ErrInvalidCredentials`, `ErrUserNotFound`, `ErrSessionNotFound` are package-level sentinels), `ErrNotFound` and `ErrForbidden` are defined in `internal/calculator/calculator.go`. The server handler uses `errors.Is(err, calculator.ErrNotFound)` after the service wraps the error with `%w` — this correctly unwraps through the chain.

**`chi.URLParam` unit test pattern**

Unit tests for handlers that read path parameters use a `newChiRequest` helper that creates a `chi.RouteContext` with the parameter pre-populated, then stores it in the request context. This allows the handler to call `chi.URLParam(r, "id")` in a unit test without needing a live chi router to dispatch the request.

### Technical Challenges

**No significant challenges.** The two-phase query pattern and `json.RawMessage` usage were clear from the requirements. The `newChiRequest` helper was necessary to make `chi.URLParam` work in isolation from the router in unit tests.

---

## Task: INFR-US5-A004 — Implement update calculator endpoint with config schema validation

**Requirements:** 1.2.3, 1.2.6

### Decisions

**`Updater` interface takes `(ctx, id, config)` — no `userID`**

`Service.Update` uses a two-phase approach: it calls `getter.GetCalculator(ctx, id, userID)` first to verify ownership and produce distinct `ErrNotFound` vs `ErrForbidden` signals, then calls `updater.UpdateCalculator(ctx, id, config)` without userID (ownership is already confirmed). The repository `UpdateCalculator` queries `WHERE id = $1 AND is_deleted = FALSE`. This keeps the update SQL simple while preserving the 403 vs 404 distinction established in A003.

**Config validation rejects `null` explicitly**

The handler validates that `config` is a JSON object by unmarshaling into `map[string]json.RawMessage`. However, `json.Unmarshal([]byte("null"), &obj)` returns `nil` error with a nil map — `null` is valid JSON but not a JSON object. An explicit `obj == nil` check is required in addition to the error check: `if err != nil || obj == nil`. Without this, `{"config":null}` would bypass validation and reach the database, producing a 500 from the NOT NULL constraint instead of the correct 400.

**`config_version` incremented atomically in SQL**

The UPDATE statement uses `config_version = config_version + 1`, which is an atomic increment at the database level. This avoids read-modify-write races and ensures monotonically increasing version numbers without application-level coordination. The RETURNING clause returns the new `config_version` value so the response reflects the persisted state.

**Response shape reuses `calculatorResponse`**

The PUT response reuses the same `calculatorResponse` struct as GET, returning `id`, `config`, `config_version`, `created_at`, and `updated_at`. This is consistent and gives the dashboard the new `config_version` and `updated_at` values after a save.

### Technical Challenges

**`json.Unmarshal` null behavior**

`json.Unmarshal([]byte("null"), &obj)` returns `nil` error and sets `obj` to `nil`. This is Go's defined behavior for decoding JSON `null` into a pointer or map — the target is set to its zero value (nil). The code review caught this as a validation gap. Fixed by adding `|| obj == nil` to the validation condition and adding `TestUpdateCalculatorHandler_NullConfig` to cover the path.

---

## Task: INFR-US5-A005 — Implement soft-delete calculator endpoint

**Requirements:** 1.2.4, 1.2.8

### Decisions

**`ExecContext` + `RowsAffected` for soft-delete (not `QueryRowContext` with RETURNING)**

`DeleteCalculator` uses `ExecContext` rather than `QueryRowContext` because the delete operation returns no data. The UPDATE statement sets `is_deleted = TRUE WHERE id = $1 AND is_deleted = FALSE`. `RowsAffected()` distinguishes between a successful delete (1 row) and a not-found case (0 rows). Unlike `UpdateCalculator` (which uses RETURNING to get the updated row back), the delete endpoint returns 204 No Content with no body, so there is nothing to scan.

**`ErrNotFound` from `RowsAffected() == 0` (no `ErrForbidden` from the repository)**

`DeleteCalculator` does not accept `userID` and does not perform an ownership check — it only verifies the row exists (i.e., `is_deleted = FALSE`). Ownership verification is done at the service layer: `Service.Delete` calls `getter.GetCalculator(ctx, id, userID)` first, which returns `ErrForbidden` if the row belongs to a different user. If `GetCalculator` succeeds, the caller is confirmed as the owner before the delete is issued. The repository's `0 rows affected → ErrNotFound` path handles only the race condition where the calculator was deleted between the ownership check and the delete query. This is consistent with how `Service.Update` works.

**`RowsAffected()` error is checked (not ignored)**

Code review rejected the initial `n, _ := result.RowsAffected()` pattern as a violation of the no-ignored-errors convention. The fix wraps the error: `return fmt.Errorf("checking rows affected: %w", err)`. A corresponding `TestDeleteCalculator_RowsAffectedError` test uses `sqlmock.NewErrorResult(wantErr)` to cover this path.

**204 No Content response (no body)**

The delete handler calls `w.WriteHeader(http.StatusNoContent)` on success — no JSON body. This is the standard REST response for a successful DELETE. The test verifies `rec.Code == http.StatusNoContent`.

**`CalculatorDeleter` interface at consumer (server package)**

Following the interfaces-at-consumer convention, `CalculatorDeleter` is defined in `internal/server/calculator.go` alongside the other `Calculator*` interfaces. `CalculatorService` embeds all five: `CalculatorCreator`, `CalculatorLister`, `CalculatorGetter`, `CalculatorUpdater`, `CalculatorDeleter`. `calculator.Service` satisfies all five without knowing about the server package.

### Technical Challenges

**No significant challenges.** The implementation follows the same two-phase ownership + mutation pattern as `Update` (A003/A004). The `ExecContext` + `RowsAffected` pattern is the standard approach for UPDATE-based soft-deletes in Go with `database/sql`.

---

## Task: INFR-US5-A007 — Implement public config endpoint with cache headers

**Requirements:** 1.9.3, 1.9.4

### Decisions

**Separate `PublicConfigGetter` interface (not reusing `Getter`)**

`GetCalculator` requires a `userID` and performs an ownership check — it returns `ErrForbidden` for cross-user access. The public config endpoint has no auth context; passing an empty string for `userID` would be confusing and error-prone. A dedicated `PublicConfigGetter` interface with `GetPublicCalculatorConfig(ctx, id)` is added to `internal/calculator/calculator.go`. This makes the intent explicit and avoids overloading `GetCalculator` with optional ownership semantics.

**`GetPublicCalculatorConfig` shares the same SQL query body as `GetCalculator`**

Both queries use `SELECT id, user_id, config, config_version, is_deleted, created_at, updated_at FROM calculators WHERE id = $1 AND is_deleted = FALSE`. The difference is that `GetPublicCalculatorConfig` omits the `c.UserID != userID` check after scanning. The soft-delete filter is retained: a deleted calculator is not public. This satisfies the requirement that 404 is returned for soft-deleted calculators.

**`Cache-Control` header set before `WriteJSON`**

`WriteJSON` calls `w.WriteHeader(statusCode)` internally after setting `Content-Type`. Once `WriteHeader` is called, response headers are finalized and any subsequent `w.Header().Set(...)` calls are silently ignored. `publicConfigHandler` therefore sets `w.Header().Set("Cache-Control", "public, max-age=300")` before calling `WriteJSON`. The test `TestPublicConfigHandler_Success` asserts `rec.Header().Get("Cache-Control") == "public, max-age=300"` to enforce this ordering.

**`publicConfigResponse` omits `created_at`, `updated_at`, and `user_id`**

The widget only needs `id`, `config`, and `config_version` to render a calculator. Omitting `user_id`, `created_at`, and `updated_at` avoids leaking builder account metadata to public consumers. This aligns with OWASP A01 guidance in `SYSTEM_DESIGN.md`: "the public config endpoint does not expose builder account details, billing status, or internal metadata."

**`MountPublicCalculators` uses `s.publicGroup.Get(...)` directly**

Unlike `MountCalculators`, which calls `s.Authenticated(validator)` to create an auth-gated sub-router on `privateGroup`, `MountPublicCalculators` registers directly on `s.publicGroup`. The public group already has wildcard CORS applied (`publicCORS()`). No auth middleware is added — this is the correct behavior for a widget-facing endpoint. `TestMountPublicCalculators_RegistersRoute` verifies the route responds 200 with no `Authorization` header, confirming it bypasses auth.

**6th arg to `NewService` follows the established positional pattern**

`NewService` was already accepting 5 positional interface arguments. Adding `publicConfigGetter PublicConfigGetter` as a 6th maintains the pattern. In `main.go`, `calcRepo` is passed for all 6 since `PostgresCalculatorRepository` implements all six interfaces. All existing `NewService(...)` callsites in `calculator_test.go` were updated to include `&stubPublicConfigGetter{}` as the 6th arg.

### Technical Challenges

**No significant challenges.** The main design decision was the header ordering constraint (`Cache-Control` must precede `WriteJSON`), which was anticipated from the task description. The test asserts the header value to enforce the ordering at the test level.
