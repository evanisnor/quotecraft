# Decisions — February 23, 2026

## Task: INFR-US5-A002 — Implement list calculators endpoint (scoped to authenticated user)

**Requirements:** 1.2.2

### Decisions

**`Lister` interface separate from `Creator`**

`ListCalculators` is defined on a new `Lister` interface, separate from `Creator`. `Create` only needs `Creator`; `List` only needs `Lister`. ISP: each consumer takes exactly the capability it needs. `PostgresCalculatorRepository` satisfies both. `NewService` now accepts both `creator Creator` and `lister Lister`. In `main.go`, `calcRepo` is passed for both since `PostgresCalculatorRepository` implements both interfaces.

**`CalculatorLister` defined in `server` package (consumer)**

Per the interfaces-at-consumer convention, `CalculatorLister` is defined in `internal/server/calculator.go`. `CalculatorService` is updated to embed both `CalculatorCreator` and `CalculatorLister`. The `calculator.Service` satisfies both without knowing about the server package.

**`make([]*Calculator, 0)` in `ListCalculators` for empty-list serialization**

Initializing the result slice with `make([]*Calculator, 0)` (rather than `var calcs []*Calculator`) ensures that when zero rows are returned, the variable is a non-nil empty slice. This serializes to `[]` in JSON rather than `null`. The `TestListCalculatorsHandler_Empty` test explicitly asserts `env.Data != nil` to enforce this invariant.

**Query uses `WHERE user_id = $1 AND is_deleted = FALSE ORDER BY updated_at DESC`**

The ownership filter (`user_id = $1`) is enforced at the database level, not the application level. The `user_id` value is derived exclusively from `UserIDFromContext(r.Context())` — the authenticated session — never from user-supplied request parameters. The soft-delete filter (`is_deleted = FALSE`) correctly excludes deleted calculators. Ordering by `updated_at DESC` gives the most recently modified calculator first, which is the natural UX ordering for a builder dashboard.

**`calculatorSummary` response type returns `id`, `created_at`, `updated_at`**

The list response omits `config`, `config_version`, `is_deleted`, and `user_id`. The dashboard needs a name/description per calculator (requirement 1.2.7), but those fields live inside the `config` JSONB and are not yet parsed by the API — that is deferred to the GET endpoint (INFR-US5-A003) and config update (INFR-US5-A004) tasks. The current summary is sufficient for the dashboard to render a list of calculators identified by UUID.

**`rows.Close()` deferred inside `ListCalculators`**

`defer rows.Close()` is called immediately after `QueryContext` succeeds. This is idiomatic Go and ensures rows are closed even if a scan error occurs mid-iteration. The `rows.Err()` check after the loop is still necessary — `rows.Close()` does not surface iteration errors.

### Technical Challenges

**`RowError(0, wantErr)` syntax for sqlmock v1**

sqlmock v1 supports injecting errors into specific rows via the `RowError(rowIndex int, err error)` method on `*Rows`. For `TestListCalculators_RowsError`, a valid row is added first (so `rows.Next()` iterates once), then `RowError(0, wantErr)` is called so that `rows.Err()` returns the configured error after the first row. This exercises the `rows.Err()` error path without triggering a scan failure.

---

## Task: INFR-US5-A003 — Implement get single calculator endpoint (ownership-gated)

**Requirements:** 1.2.2 (implied), INFR-US5 acceptance criteria

### Decisions

**Two-phase fetch: query by `id` only, then ownership check in Go**

`GetCalculator` queries `WHERE id = $1 AND is_deleted = FALSE` — deliberately excluding `user_id` from the WHERE clause. After the row is fetched, a Go-level check `c.UserID != userID` produces `ErrForbidden`. This design allows the repository to return distinct `ErrNotFound` vs `ErrForbidden` signals, enabling the handler to respond 404 vs 403. If the query included `WHERE id = $1 AND user_id = $2 AND is_deleted = FALSE`, both "not found" and "wrong user" would collapse to `sql.ErrNoRows → ErrNotFound`, and we could not return a 403.

**Returning 403 for ownership mismatch (not 404)**

The handler maps `ErrForbidden → 403`, not 404. This is a deliberate product decision documented in the function. It provides clear feedback to dashboard clients (a logged-in user tried to access a calculator they don't own). If the product requirement changes to hide the existence of others' calculators entirely, the behavior can be changed by returning 404 in both `ErrNotFound` and `ErrForbidden` cases.

**`json.RawMessage` for config field**

`calculatorResponse.Config` is `json.RawMessage` so the JSONB column value is embedded as a live JSON object in the API response, not base64-encoded. This is critical for the widget: it must parse the config as a structured JSON document, and a base64-encoded string would require an extra decode step in the widget bundle. The handler casts `calc.Config` (a `[]byte` from PostgreSQL JSONB) to `json.RawMessage` directly — zero-copy, no re-parsing.

**`ErrNotFound` and `ErrForbidden` sentinel errors in `calculator` package**

Following the pattern from `auth` (where `ErrInvalidCredentials`, `ErrUserNotFound`, `ErrSessionNotFound` are package-level sentinels), `ErrNotFound` and `ErrForbidden` are defined in `internal/calculator/calculator.go`. The server handler uses `errors.Is(err, calculator.ErrNotFound)` after the service wraps the error with `%w` — this correctly unwraps through the chain.

**`chi.URLParam` unit test pattern**

Unit tests for handlers that read path parameters use a `newChiRequest` helper that creates a `chi.RouteContext` with the parameter pre-populated, then stores it in the request context. This allows the handler to call `chi.URLParam(r, "id")` in a unit test without needing a live chi router to dispatch the request.

### Technical Challenges

**No significant challenges.** The two-phase query pattern and `json.RawMessage` usage were clear from the requirements. The `newChiRequest` helper was necessary to make `chi.URLParam` work in isolation from the router in unit tests.

---

## Task: INFR-US5-A004 — Implement update calculator endpoint with config schema validation

**Requirements:** 1.2.3, 1.2.6

### Decisions

**`Updater` interface takes `(ctx, id, config)` — no `userID`**

`Service.Update` uses a two-phase approach: it calls `getter.GetCalculator(ctx, id, userID)` first to verify ownership and produce distinct `ErrNotFound` vs `ErrForbidden` signals, then calls `updater.UpdateCalculator(ctx, id, config)` without userID (ownership is already confirmed). The repository `UpdateCalculator` queries `WHERE id = $1 AND is_deleted = FALSE`. This keeps the update SQL simple while preserving the 403 vs 404 distinction established in A003.

**Config validation rejects `null` explicitly**

The handler validates that `config` is a JSON object by unmarshaling into `map[string]json.RawMessage`. However, `json.Unmarshal([]byte("null"), &obj)` returns `nil` error with a nil map — `null` is valid JSON but not a JSON object. An explicit `obj == nil` check is required in addition to the error check: `if err != nil || obj == nil`. Without this, `{"config":null}` would bypass validation and reach the database, producing a 500 from the NOT NULL constraint instead of the correct 400.

**`config_version` incremented atomically in SQL**

The UPDATE statement uses `config_version = config_version + 1`, which is an atomic increment at the database level. This avoids read-modify-write races and ensures monotonically increasing version numbers without application-level coordination. The RETURNING clause returns the new `config_version` value so the response reflects the persisted state.

**Response shape reuses `calculatorResponse`**

The PUT response reuses the same `calculatorResponse` struct as GET, returning `id`, `config`, `config_version`, `created_at`, and `updated_at`. This is consistent and gives the dashboard the new `config_version` and `updated_at` values after a save.

### Technical Challenges

**`json.Unmarshal` null behavior**

`json.Unmarshal([]byte("null"), &obj)` returns `nil` error and sets `obj` to `nil`. This is Go's defined behavior for decoding JSON `null` into a pointer or map — the target is set to its zero value (nil). The code review caught this as a validation gap. Fixed by adding `|| obj == nil` to the validation condition and adding `TestUpdateCalculatorHandler_NullConfig` to cover the path.
