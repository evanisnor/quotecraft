# Decisions — February 23, 2026

## Task: INFR-US5-A002 — Implement list calculators endpoint (scoped to authenticated user)

**Requirements:** 1.2.2

### Decisions

**`Lister` interface separate from `Creator`**

`ListCalculators` is defined on a new `Lister` interface, separate from `Creator`. `Create` only needs `Creator`; `List` only needs `Lister`. ISP: each consumer takes exactly the capability it needs. `PostgresCalculatorRepository` satisfies both. `NewService` now accepts both `creator Creator` and `lister Lister`. In `main.go`, `calcRepo` is passed for both since `PostgresCalculatorRepository` implements both interfaces.

**`CalculatorLister` defined in `server` package (consumer)**

Per the interfaces-at-consumer convention, `CalculatorLister` is defined in `internal/server/calculator.go`. `CalculatorService` is updated to embed both `CalculatorCreator` and `CalculatorLister`. The `calculator.Service` satisfies both without knowing about the server package.

**`make([]*Calculator, 0)` in `ListCalculators` for empty-list serialization**

Initializing the result slice with `make([]*Calculator, 0)` (rather than `var calcs []*Calculator`) ensures that when zero rows are returned, the variable is a non-nil empty slice. This serializes to `[]` in JSON rather than `null`. The `TestListCalculatorsHandler_Empty` test explicitly asserts `env.Data != nil` to enforce this invariant.

**Query uses `WHERE user_id = $1 AND is_deleted = FALSE ORDER BY updated_at DESC`**

The ownership filter (`user_id = $1`) is enforced at the database level, not the application level. The `user_id` value is derived exclusively from `UserIDFromContext(r.Context())` — the authenticated session — never from user-supplied request parameters. The soft-delete filter (`is_deleted = FALSE`) correctly excludes deleted calculators. Ordering by `updated_at DESC` gives the most recently modified calculator first, which is the natural UX ordering for a builder dashboard.

**`calculatorSummary` response type returns `id`, `created_at`, `updated_at`**

The list response omits `config`, `config_version`, `is_deleted`, and `user_id`. The dashboard needs a name/description per calculator (requirement 1.2.7), but those fields live inside the `config` JSONB and are not yet parsed by the API — that is deferred to the GET endpoint (INFR-US5-A003) and config update (INFR-US5-A004) tasks. The current summary is sufficient for the dashboard to render a list of calculators identified by UUID.

**`rows.Close()` deferred inside `ListCalculators`**

`defer rows.Close()` is called immediately after `QueryContext` succeeds. This is idiomatic Go and ensures rows are closed even if a scan error occurs mid-iteration. The `rows.Err()` check after the loop is still necessary — `rows.Close()` does not surface iteration errors.

### Technical Challenges

**`RowError(0, wantErr)` syntax for sqlmock v1**

sqlmock v1 supports injecting errors into specific rows via the `RowError(rowIndex int, err error)` method on `*Rows`. For `TestListCalculators_RowsError`, a valid row is added first (so `rows.Next()` iterates once), then `RowError(0, wantErr)` is called so that `rows.Err()` returns the configured error after the first row. This exercises the `rows.Err()` error path without triggering a scan failure.

---

## Task: INFR-US5-A003 — Implement get single calculator endpoint (ownership-gated)

**Requirements:** 1.2.2 (implied), INFR-US5 acceptance criteria

### Decisions

**Two-phase fetch: query by `id` only, then ownership check in Go**

`GetCalculator` queries `WHERE id = $1 AND is_deleted = FALSE` — deliberately excluding `user_id` from the WHERE clause. After the row is fetched, a Go-level check `c.UserID != userID` produces `ErrForbidden`. This design allows the repository to return distinct `ErrNotFound` vs `ErrForbidden` signals, enabling the handler to respond 404 vs 403. If the query included `WHERE id = $1 AND user_id = $2 AND is_deleted = FALSE`, both "not found" and "wrong user" would collapse to `sql.ErrNoRows → ErrNotFound`, and we could not return a 403.

**Returning 403 for ownership mismatch (not 404)**

The handler maps `ErrForbidden → 403`, not 404. This is a deliberate product decision documented in the function. It provides clear feedback to dashboard clients (a logged-in user tried to access a calculator they don't own). If the product requirement changes to hide the existence of others' calculators entirely, the behavior can be changed by returning 404 in both `ErrNotFound` and `ErrForbidden` cases.

**`json.RawMessage` for config field**

`calculatorResponse.Config` is `json.RawMessage` so the JSONB column value is embedded as a live JSON object in the API response, not base64-encoded. This is critical for the widget: it must parse the config as a structured JSON document, and a base64-encoded string would require an extra decode step in the widget bundle. The handler casts `calc.Config` (a `[]byte` from PostgreSQL JSONB) to `json.RawMessage` directly — zero-copy, no re-parsing.

**`ErrNotFound` and `ErrForbidden` sentinel errors in `calculator` package**

Following the pattern from `auth` (where `ErrInvalidCredentials`, `ErrUserNotFound`, `ErrSessionNotFound` are package-level sentinels), `ErrNotFound` and `ErrForbidden` are defined in `internal/calculator/calculator.go`. The server handler uses `errors.Is(err, calculator.ErrNotFound)` after the service wraps the error with `%w` — this correctly unwraps through the chain.

**`chi.URLParam` unit test pattern**

Unit tests for handlers that read path parameters use a `newChiRequest` helper that creates a `chi.RouteContext` with the parameter pre-populated, then stores it in the request context. This allows the handler to call `chi.URLParam(r, "id")` in a unit test without needing a live chi router to dispatch the request.

### Technical Challenges

**No significant challenges.** The two-phase query pattern and `json.RawMessage` usage were clear from the requirements. The `newChiRequest` helper was necessary to make `chi.URLParam` work in isolation from the router in unit tests.

---

## Task: INFR-US5-A004 — Implement update calculator endpoint with config schema validation

**Requirements:** 1.2.3, 1.2.6

### Decisions

**`Updater` interface takes `(ctx, id, config)` — no `userID`**

`Service.Update` uses a two-phase approach: it calls `getter.GetCalculator(ctx, id, userID)` first to verify ownership and produce distinct `ErrNotFound` vs `ErrForbidden` signals, then calls `updater.UpdateCalculator(ctx, id, config)` without userID (ownership is already confirmed). The repository `UpdateCalculator` queries `WHERE id = $1 AND is_deleted = FALSE`. This keeps the update SQL simple while preserving the 403 vs 404 distinction established in A003.

**Config validation rejects `null` explicitly**

The handler validates that `config` is a JSON object by unmarshaling into `map[string]json.RawMessage`. However, `json.Unmarshal([]byte("null"), &obj)` returns `nil` error with a nil map — `null` is valid JSON but not a JSON object. An explicit `obj == nil` check is required in addition to the error check: `if err != nil || obj == nil`. Without this, `{"config":null}` would bypass validation and reach the database, producing a 500 from the NOT NULL constraint instead of the correct 400.

**`config_version` incremented atomically in SQL**

The UPDATE statement uses `config_version = config_version + 1`, which is an atomic increment at the database level. This avoids read-modify-write races and ensures monotonically increasing version numbers without application-level coordination. The RETURNING clause returns the new `config_version` value so the response reflects the persisted state.

**Response shape reuses `calculatorResponse`**

The PUT response reuses the same `calculatorResponse` struct as GET, returning `id`, `config`, `config_version`, `created_at`, and `updated_at`. This is consistent and gives the dashboard the new `config_version` and `updated_at` values after a save.

### Technical Challenges

**`json.Unmarshal` null behavior**

`json.Unmarshal([]byte("null"), &obj)` returns `nil` error and sets `obj` to `nil`. This is Go's defined behavior for decoding JSON `null` into a pointer or map — the target is set to its zero value (nil). The code review caught this as a validation gap. Fixed by adding `|| obj == nil` to the validation condition and adding `TestUpdateCalculatorHandler_NullConfig` to cover the path.

---

## Task: INFR-US5-A005 — Implement soft-delete calculator endpoint

**Requirements:** 1.2.4, 1.2.8

### Decisions

**`ExecContext` + `RowsAffected` for soft-delete (not `QueryRowContext` with RETURNING)**

`DeleteCalculator` uses `ExecContext` rather than `QueryRowContext` because the delete operation returns no data. The UPDATE statement sets `is_deleted = TRUE WHERE id = $1 AND is_deleted = FALSE`. `RowsAffected()` distinguishes between a successful delete (1 row) and a not-found case (0 rows). Unlike `UpdateCalculator` (which uses RETURNING to get the updated row back), the delete endpoint returns 204 No Content with no body, so there is nothing to scan.

**`ErrNotFound` from `RowsAffected() == 0` (no `ErrForbidden` from the repository)**

`DeleteCalculator` does not accept `userID` and does not perform an ownership check — it only verifies the row exists (i.e., `is_deleted = FALSE`). Ownership verification is done at the service layer: `Service.Delete` calls `getter.GetCalculator(ctx, id, userID)` first, which returns `ErrForbidden` if the row belongs to a different user. If `GetCalculator` succeeds, the caller is confirmed as the owner before the delete is issued. The repository's `0 rows affected → ErrNotFound` path handles only the race condition where the calculator was deleted between the ownership check and the delete query. This is consistent with how `Service.Update` works.

**`RowsAffected()` error is checked (not ignored)**

Code review rejected the initial `n, _ := result.RowsAffected()` pattern as a violation of the no-ignored-errors convention. The fix wraps the error: `return fmt.Errorf("checking rows affected: %w", err)`. A corresponding `TestDeleteCalculator_RowsAffectedError` test uses `sqlmock.NewErrorResult(wantErr)` to cover this path.

**204 No Content response (no body)**

The delete handler calls `w.WriteHeader(http.StatusNoContent)` on success — no JSON body. This is the standard REST response for a successful DELETE. The test verifies `rec.Code == http.StatusNoContent`.

**`CalculatorDeleter` interface at consumer (server package)**

Following the interfaces-at-consumer convention, `CalculatorDeleter` is defined in `internal/server/calculator.go` alongside the other `Calculator*` interfaces. `CalculatorService` embeds all five: `CalculatorCreator`, `CalculatorLister`, `CalculatorGetter`, `CalculatorUpdater`, `CalculatorDeleter`. `calculator.Service` satisfies all five without knowing about the server package.

### Technical Challenges

**No significant challenges.** The implementation follows the same two-phase ownership + mutation pattern as `Update` (A003/A004). The `ExecContext` + `RowsAffected` pattern is the standard approach for UPDATE-based soft-deletes in Go with `database/sql`.

---

## Task: INFR-US5-A007 — Implement public config endpoint with cache headers

**Requirements:** 1.9.3, 1.9.4

### Decisions

**Separate `PublicConfigGetter` interface (not reusing `Getter`)**

`GetCalculator` requires a `userID` and performs an ownership check — it returns `ErrForbidden` for cross-user access. The public config endpoint has no auth context; passing an empty string for `userID` would be confusing and error-prone. A dedicated `PublicConfigGetter` interface with `GetPublicCalculatorConfig(ctx, id)` is added to `internal/calculator/calculator.go`. This makes the intent explicit and avoids overloading `GetCalculator` with optional ownership semantics.

**`GetPublicCalculatorConfig` shares the same SQL query body as `GetCalculator`**

Both queries use `SELECT id, user_id, config, config_version, is_deleted, created_at, updated_at FROM calculators WHERE id = $1 AND is_deleted = FALSE`. The difference is that `GetPublicCalculatorConfig` omits the `c.UserID != userID` check after scanning. The soft-delete filter is retained: a deleted calculator is not public. This satisfies the requirement that 404 is returned for soft-deleted calculators.

**`Cache-Control` header set before `WriteJSON`**

`WriteJSON` calls `w.WriteHeader(statusCode)` internally after setting `Content-Type`. Once `WriteHeader` is called, response headers are finalized and any subsequent `w.Header().Set(...)` calls are silently ignored. `publicConfigHandler` therefore sets `w.Header().Set("Cache-Control", "public, max-age=300")` before calling `WriteJSON`. The test `TestPublicConfigHandler_Success` asserts `rec.Header().Get("Cache-Control") == "public, max-age=300"` to enforce this ordering.

**`publicConfigResponse` omits `created_at`, `updated_at`, and `user_id`**

The widget only needs `id`, `config`, and `config_version` to render a calculator. Omitting `user_id`, `created_at`, and `updated_at` avoids leaking builder account metadata to public consumers. This aligns with OWASP A01 guidance in `SYSTEM_DESIGN.md`: "the public config endpoint does not expose builder account details, billing status, or internal metadata."

**`MountPublicCalculators` uses `s.publicGroup.Get(...)` directly**

Unlike `MountCalculators`, which calls `s.Authenticated(validator)` to create an auth-gated sub-router on `privateGroup`, `MountPublicCalculators` registers directly on `s.publicGroup`. The public group already has wildcard CORS applied (`publicCORS()`). No auth middleware is added — this is the correct behavior for a widget-facing endpoint. `TestMountPublicCalculators_RegistersRoute` verifies the route responds 200 with no `Authorization` header, confirming it bypasses auth.

**6th arg to `NewService` follows the established positional pattern**

`NewService` was already accepting 5 positional interface arguments. Adding `publicConfigGetter PublicConfigGetter` as a 6th maintains the pattern. In `main.go`, `calcRepo` is passed for all 6 since `PostgresCalculatorRepository` implements all six interfaces. All existing `NewService(...)` callsites in `calculator_test.go` were updated to include `&stubPublicConfigGetter{}` as the 6th arg.

### Technical Challenges

**No significant challenges.** The main design decision was the header ordering constraint (`Cache-Control` must precede `WriteJSON`), which was anticipated from the task description. The test asserts the header value to enforce the ordering at the test level.

---

## Task: INFR-US6-A004 — Add storage and CDN configuration sections to config.yaml

**Requirements:** 1.8.5, 1.3.7

### Decisions

**Three new config types added to the `config` package: `StorageConfig`, `S3Config`, `FilesystemStorageConfig`, `CDNConfig`**

All four types are added to `api/internal/config/config.go` and wired into the root `Config` struct. `StorageConfig` uses a `provider` discriminator field (`"s3"` or `"filesystem"`) to select the active backend at runtime. The S3 config covers both AWS S3 (empty endpoint = AWS default) and MinIO (explicit endpoint). The filesystem config is a single field (`base_dir`). The CDN config has `base_url` (where public asset URLs are rooted), `widget_dir` (local path to the built widget bundle for dev-mode serving), and `serve_local` (enables the `/static/*` handler).

**`Default()` mirrors `config.yaml` exactly**

The Go defaults in `Default()` are identical to the values in `config.yaml` so that running without a config file produces the same behavior as running with the provided file. This avoids silent divergence between the two.

**`config.yaml` credentials are well-known MinIO defaults**

`minioadmin`/`minioadmin` are the default MinIO credentials documented in the MinIO documentation. They are appropriate for local development infrastructure only. No production secrets are committed.

### Technical Challenges

**No significant challenges.** Pure configuration scaffolding. The SYSTEM_DESIGN.md contained the exact YAML shape required.

---

## Task: INFR-US6-A001 — Define `Storage` interface and implement S3-compatible adapter

**Requirements:** 1.8.5, 1.3.7

### Decisions

**`s3API` local interface for test injection**

The `s3API` interface (`PutObject`, `DeleteObject`) is extracted from the AWS S3 client in the `storage` package. This allows `stubS3API` to be used in tests without making real AWS API calls. The `S3Adapter` takes an `s3API` in its constructor, and `NewS3Adapter` is the test constructor while `NewS3AdapterFromConfig` is the production factory.

**`configLoader` function type for `awsconfig.LoadDefaultConfig` injection**

`awsconfig.LoadDefaultConfig` was not testable in isolation — it would always use the real AWS SDK loader. A `configLoader` function type was introduced and the implementation moved to `newS3AdapterWithLoader(ctx, cfg, baseURL, loader)`. `NewS3AdapterFromConfig` delegates to it, passing `awsconfig.LoadDefaultConfig` as the loader. Tests can pass a failing loader to cover the error path. This is the minimal change needed to achieve 100% branch coverage.

**`StubStorage` in `testing.go`**

Per SKILL.md, exported interfaces require a co-located stub in a `testing.go` file for use by downstream consumers. `StubStorage` follows the `StubEventStore` pattern: configurable `UploadFunc`, `GetURLFunc`, `DeleteFunc` fields with sensible defaults via `NewStubStorage()`, plus captured call state (`LastUploadKey`, `LastUploadContentType`, `LastDeleteKey`) for assertion use in downstream tests.

**AWS SDK v2 `go.mod` annotations**

Initial implementation had all four AWS SDK packages marked `// indirect`. After the code reviewer caught this, `go get` was run for the four directly-imported packages, promoting them to direct dependencies. `go mod tidy` confirmed the full transitive graph is correct.

**100% coverage for `testing.go`**

`testing.go` is compiled as a regular Go file (not a `_test.go` file), so its lines are included in coverage calculations. Tests for `StubStorage` were added to `s3_test.go` to cover all `StubStorage` methods and verify the configurable func fields and call capture behavior.

### Technical Challenges

**Code review caught `go.mod` indirect annotations.** The Golang agent that implemented the initial version had added the AWS SDK dependencies but all were marked `// indirect`. Fixed by re-running `go get` for the four directly-imported packages.

**Coverage dropped when `testing.go` was added.** Coverage fell from 96.2% to 73% after adding `testing.go` because `StubStorage` methods were not exercised. Fixed by adding `TestStubStorage_*` tests that also serve as usage examples for downstream consumers.

---

## Task: INFR-US6-A002 — Implement filesystem storage adapter for CI/test environments

**Requirements:** 1.8.5, 1.3.7

### Decisions

**`fileCreator` function type for close error injection**

`os.Create` returns `*os.File`. The `f.Close()` error on the success path is mandatory to check per SKILL.md. To test this branch, a `fileCreator` function type was introduced (same pattern as `configLoader` in s3.go). The internal `upload(...)` function accepts the creator; `Upload` delegates with `os.Create`. Tests inject `failCloseWriter` (a `io.WriteCloser` whose `Close()` returns an error) to cover the branch without OS-level mocking.

**`defer f.Close()` retained for error-path cleanup**

After extracting the explicit `f.Close()` check on the success path, `defer f.Close()` is kept for early-return cleanup (e.g., if `io.Copy` returns an error). The deferred close on an already-closed file is a no-op. This is idiomatic Go.

**`Delete` is idempotent (returns nil for missing files)**

S3's `DeleteObject` is silent about non-existent keys. The filesystem adapter matches this behaviour: `os.IsNotExist(err)` → `return nil`. This simplifies consumer code (callers don't need to handle not-found on cleanup).

**`filepath.FromSlash(key)` for cross-platform path handling**

Keys use forward slashes (`images/logo.png`). `filepath.FromSlash` converts to OS-native separators before `filepath.Join`. Tests pass on both Linux (CI) and macOS (local dev).

### Technical Challenges

**Code reviewer required explicit `f.Close()` check.** Initial implementation used only `defer f.Close()`, which silently ignores the return value. The fix introduced the `fileCreator` injection pattern and the two-close idiom to achieve both correctness and 100% coverage.

---

## Task: INFR-US6-A003 — Add MinIO to Docker Compose with health check, persistent volume, and default bucket creation

**Requirements:** 1.8.5, 1.3.7

### Decisions

**`minio-init` container for bucket creation**

MinIO does not auto-create buckets on startup. A separate `minio-init` service using `minio/mc` creates the `quotecraft-assets` bucket. It uses `depends_on: condition: service_healthy` so it only runs after MinIO passes the liveness probe. The `|| true` makes it idempotent — subsequent `docker compose up` runs don't fail if the bucket already exists. `restart: 'no'` ensures it's a one-shot init.

**Health check uses `/minio/health/live` endpoint**

MinIO exposes `/minio/health/live` as a standard liveness probe. `curl -f` returns non-zero on HTTP error codes. `start_period: 20s` gives MinIO more startup time than PostgreSQL (which uses 10s) since the object storage server has a longer initialization path.

**Credentials use environment variable defaults**

`${MINIO_ROOT_USER:-minioadmin}` / `${MINIO_ROOT_PASSWORD:-minioadmin}` follow the same pattern as PostgreSQL. Well-known MinIO dev defaults are acceptable for local development.

**Named volume `minio-data`**

Persistent volume `minio-data` mounted at `/data` ensures uploaded assets survive `docker compose stop` + `docker compose start` cycles, matching the `postgres-data` pattern.

### Technical Challenges

**No significant challenges.** The SYSTEM_DESIGN.md specified the exact MinIO configuration required (ports, credentials, bucket name). The only decision was the bucket creation mechanism (init container vs. entrypoint script).

---

## Task: INFR-US6-A007 — Set up widget bundle build pipeline with content-hashed filename

**Requirements:** 1.8.5

### Decisions

**`write: false` + manual file write for content hashing**

esbuild does not natively output content-hashed filenames for IIFE bundles. The solution: use `write: false` to get `result.outputFiles[0].contents` (Uint8Array) in memory, compute `sha256(contents).slice(0, 8)` as the hash, then write `dist/widget.<hash8>.js` and `dist/manifest.json` manually. The 8-character hex prefix gives 32 bits of collision space, which is more than sufficient for a single-file build artifact.

**`manifest.json` for stable filename lookup**

The `dist/` directory contains at most one `widget.[a-f0-9]{8}.js` at a time after cleanup. A `manifest.json` file `{ "widget": "widget.<hash8>.js" }` is written alongside the bundle so the API's static file handler and other tooling can locate the current build without globbing. The manifest key `"widget"` is the canonical name for the bundle (additional assets can be added under new keys when needed).

**Watch mode keeps fixed filename**

Watch mode (`--watch`) still writes to `dist/widget.js` without hashing. This avoids breaking the dev-mode URL on every rebuild. Content hashing is a production concern (cache-busting CDN deployments); in watch mode, browsers are expected to reload manually or via HMR, so a stable filename is preferable.

**Cleanup of old hashed builds**

Before writing the new hashed file, the build script removes any existing `widget.[a-f0-9]{8}.js` files from `dist/`. This prevents stale hashed builds from accumulating. The cleanup only matches the precise 8-character hex pattern (`/^widget\.[a-f0-9]{8}\.js$/`) to avoid accidentally deleting unrelated files.

**`outfile` omitted from production build options**

When `write: false` is set, esbuild ignores `outfile` for determining where to write output (nothing is written to disk). Including `outfile` in the production options would be misleading. The option is only set in watch mode where esbuild writes the file itself.

### Technical Challenges

**Code reviewer caught misleading `outfile`** in the initial implementation. The initial version included `outfile: join(distDir, 'widget.js')` in the production build options alongside `write: false`. This had no effect on behavior (the manual `writeFile` call determines the output path) but was misleading. Removed after review.

---

## Task: INFR-US6-A005 — Implement dev-mode static file handler (`/static/*` route)

**Requirements:** 1.8.5

### Decisions

**Route mounted on `s.mux` directly (not under `/v1`)**

The `/static/*` route is a dev-mode asset server, not an API endpoint. It belongs at the root level alongside `/healthz`, not under the versioned API prefix or behind any CORS group. This is consistent with how `/healthz` is mounted.

**`http.StripPrefix` + `http.FileServer(http.Dir(dir))`**

Standard Go idiom for serving a directory of files. `http.Dir` sanitizes path traversal attempts internally (`filepath.Clean` + prefix check), so `../` traversal is blocked without additional application code.

**`ServeLocal` guard in `main.go` (not inside `MountStaticFiles`)**

The decision of whether to register the route is a configuration concern, not a server concern. `MountStaticFiles` is unconditionally a "serve files from this dir" operation. The `if cfg.CDN.ServeLocal` check in `main.go` keeps policy at the wiring layer. This makes the function simple to test and keeps the server package free of CDN config awareness.

**No cache headers in dev mode**

Production CDN caching is a deployment-time concern. Dev-mode static serving does not add `Cache-Control` headers — stale caches during widget development are more disruptive than the absence of them.

### Technical Challenges

**No significant challenges.** The `http.FileServer` pattern is well-established. The route registration at root (not `/v1`) was clear from the SYSTEM_DESIGN.md description.
